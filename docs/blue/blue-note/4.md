## 算法
---
### 查找和排序（十大排序）
```java
1.冒泡排序：（每次两两比较，找到小的立刻交换）
int[] arr = {10,9,8,7,6,5,4,3,2,1};
for (int i = 0; i < arr.length-1; i++) {  //外层轮数
    for (int j = 0; j < arr.length-1-i; j++) {  //每轮两两比较，每大轮-i，因为每次都有累积一个排好在后面，所以-i
        if (arr[j]>arr[j+1]){  //注意是j不是i
            int temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp;
        }
    }
}
for (int i : arr) System.out.print(i);

----------------------------------------------------------
2.选择排序：（先记录一个最小值的下标，每次刷新记录最小值，遍历完一遍把最小值放在前面）
int[] arr = {10,9,8,7,6,5,4,3,2,1};
for (int i = 0; i < arr.length-1; i++) {  //外层循环
    int index = i;  //记录一个临时最小值下标，默认从i开始
    for (int j = i+1; j < arr.length; j++) {  //每次从i的后面开始寻找最小值，所以是i+1
        if (arr[j]<arr[index]){  //当j寻找到最小值时，就把index更新为当前j
            index=j;
        }
    }
    int temp = arr[index]; 
    arr[index] = arr[i];
    arr[i] = temp;
}
for (int i : arr) System.out.print(i);

----------------------------------------------------------
3.插入排序：（先记录一个数和一个下标，分别是插入数和插入数的前一个下标，两个作比较，前一个数大的话就交换，小就还是等于插入数）
int[] arr = {10,9,8,7,6,5,4,3,2,1};
for (int i = 0; i < arr.length; i++) {
    int invaule = arr[i];  //记录当前要比较插入的数（invaule其实就是交换中的temp）
    int inindex = i-1;  //i-1记录插入数的前一个位置（如果该位置的数大于插入数，则该数往后移一格，也就是
    //该位置+1放该数。完成交换后，位置重新-1，回归原有的inindex=i-1）
    while (inindex>=0 && arr[inindex]>invaule){  //inindex>=0是因为第一个数不用参与
        arr[inindex+1] = arr[inindex];
        inindex--;
    }
    arr[inindex+1] = invaule; //（如果该位置的数小于插入数，则该位置+1放插入数，也就是不交换）
}
for (int i : arr) System.out.print(i);

----------------------------------------------------------
4.希尔排序：（希尔排序是在插入排序的基础上，插入排序是每次间隔都为1，希尔是第一次间隔为长度/2，每次都减少一半）
int[] arr = {10,9,8,7,6,5,4,3,2,1};
for (int interval = arr.length/2; interval > 0; interval/=2) { //外层循环是增量排序（选择几个来分组排序）
    for (int i = interval; i < arr.length; i++) {  //本质是前后距离为1的，现在前后距离是interval
        int target = arr[i]; //起点为interval
        int j = i-interval;  //j原本是0，现在是i-interval才能=0
        while (j>-1 && arr[j]>target){ //前数比起点数大
            arr[j+interval]=arr[j];  //则把前数放在起点数的位置
            j-=interval; //原本是i--，但希尔是分组增量的，再选择排序的基础上的，所以要-增量
        }
        arr[j+interval]=target; //j在上一步减去了距离，现在加回来j变成0，把七点数放在前数的位置，完成交换
    }
}
for (int i : arr) System.out.print(i);

----------------------------------------------------------
5.快速排序（定基准数，左右分别找比基准数的大小，交换，然后递归调用）
int[] arr = {10,9,8,7,6,5,4,3,2,1};
quickSort(arr,0,arr.length-1);
for (int i : arr) System.out.print(i);

private static void quickSort(int[] arr,int left,int right){
    if (left > right) return; //先判断一下，给的左指针必须小于右指针
    int base = arr[left];  //先定义一个基准数，为数组的左指针位置
    int i = left;  //定义一个i保存左指针
    int j = right; //定义一个j保存右指针
    while (i != j){  //循环的条件是i和j不能相遇
        while (arr[j] >= base && i < j) j--; //先右指针开始，右指针向左走，找到大的则移动下标继续寻找
        while (arr[i] <= base && i < j) i++; //           左指针的向右走，找到小的则移动下标继续寻找
        int temp = arr[j]; //右指针找小，左指针找大，找到了就进行交换
        arr[j] = arr[i];
        arr[i] = temp;
    }
    arr[left] = arr[i]; //到这里证明第一轮找完，i和j相遇，就在相遇的位置和基准数交换一下
    arr[i] = base;
    quickSort(arr,left,i-1); //交换完基准数后，数组被分成基准数左边相对有序和右边相对有序。
    quickSort(arr,j+1,right); //分别左递归和右递归，-1是因为左边再基准数的左右两个数
}
```